#!/bin/bash
# ==============================================================================
# SCRIPT: check_disk_usage_projection
# DESCRIPTION:
#   Nagios/NRPE plugin that monitors disk usage growth over time and projects
#   "hours remaining" until full. Stores historical (timestamp, used_kb) points
#   per mountpoint in a local state directory and prunes data older than 7 days.
#
#   trend: uses two rolling windows and compares averages to compute a stable
#   growth rate (reduces false alerts from short daily spikes).
#
# DEPENDENCIES:
#   bash, df, awk, bc, getopt, date
# ==============================================================================

set -Eeuo pipefail

export LC_ALL=C
export LANG=C

readonly STATE_OK=0
readonly STATE_WARNING=1
readonly STATE_CRITICAL=2
readonly STATE_UNKNOWN=3

# Default values
THRESHOLD_WARN=24
THRESHOLD_CRIT=12
DATA_DIR="/var/tmp/disk_usage_data"
EXCLUDE_FS="tmpfs|devtmpfs|shm|efivarfs|binfmt_misc|rpc_pipefs|cgroup|tracefs|overlay|nsfs"

# Trend settings
WINDOW_HOURS=6            # compare avg used across 2 windows of this size
MIN_POINTS_PER_WINDOW=3   # require at least N samples in each window to evaluate

RESET_STATE=false

critical() { echo -n "CRITICAL: $*"; exit $STATE_CRITICAL; }
trap 'critical "script failure at line ${LINENO}"' ERR

show_help() {
  cat <<EOF
Usage: $0 [-w|-W HOURS] [-c|-C HOURS] [-x|-X FSTYPES] [--data-dir DIR] [-r|--reset] [-h|-H|--help]

Options:
  -w, -W, --warning HOURS     Hours until full for WARNING (default: 24)
  -c, -C, --critical HOURS    Hours until full for CRITICAL (default: 12)
  -x, -X, --exclude FSTYPES   Pipe-separated filesystem types to ignore
  --data-dir DIR              Location to store historical CSV files
  -r, --reset                 Remove saved state files in DATA_DIR and exit OK
  -h, -H, --help              Show this help
EOF
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || critical "required command not found: $1"
}

require_cmd df
require_cmd awk
require_cmd bc
require_cmd getopt
require_cmd date
require_cmd rm

reset_state() {
  mkdir -p "$DATA_DIR" || critical "cannot create data dir: $DATA_DIR"
  # Safety: only delete our own files
  rm -f "${DATA_DIR}/disk_"*.txt 2>/dev/null || true
  echo -n "OK: state reset in ${DATA_DIR}"
  exit $STATE_OK
}

# Projection based on two rolling windows:
# - last window:   (now - WINDOW) .. now
# - prev window:   (now - 2W) .. (now - W)
# Uses avg(used_kb) in each window to compute delta_used over WINDOW seconds.
#
# Output:
#   "<rate_mb_s> <hours_left>"
#   If warming up (insufficient history): "<rate_mb_s> -1"
get_projection() {
  local data="$1"
  local total_kb="$2"
  local now="$3"

  local w_sec=$((WINDOW_HOURS * 3600))
  local start_prev=$((now - 2*w_sec))
  local start_last=$((now - w_sec))

  local stats
  stats=$(
    printf "%s\n" "$data" | awk -F',' -v sp="$start_prev" -v sl="$start_last" -v now="$now" '
      $1 ~ /^[0-9]+$/ && $2 ~ /^[0-9]+$/ {
        ts=$1; u=$2
        if (ts >= sp && ts < sl) { sumP += u; cntP++ }
        else if (ts >= sl && ts <= now) { sumL += u; cntL++ }
        if (ts > maxTs) { maxTs=ts; lastU=u }
      }
      END {
        if (cntP>0) avgP = sumP/cntP; else avgP = -1
        if (cntL>0) avgL = sumL/cntL; else avgL = -1
        if (maxTs=="") { lastU=-1 }
        printf "%.6f %d %.6f %d %d\n", avgP, cntP, avgL, cntL, lastU
      }
    '
  )

  local avgP cntP avgL cntL lastU
  read -r avgP cntP avgL cntL lastU <<< "$stats"

  # Warm-up: need enough points in both windows
  if [[ "$cntP" -lt "$MIN_POINTS_PER_WINDOW" || "$cntL" -lt "$MIN_POINTS_PER_WINDOW" ]]; then
    echo "0.00 -1"
    return 0
  fi

  local delta_used_kb
  delta_used_kb=$(bc -l <<< "$avgL - $avgP")

  # If shrinking or flat -> stable
  if [[ "$(bc -l <<< "$delta_used_kb <= 0")" -eq 1 ]]; then
    echo "0.00 9999"
    return 0
  fi

  local rate_kb_s
  rate_kb_s=$(bc -l <<< "$delta_used_kb / $w_sec")

  local rate_mb_s
  rate_mb_s=$(printf "%.2f" "$(bc -l <<< "$rate_kb_s / 1024")")

  [[ "$lastU" =~ ^-?[0-9]+$ ]] || critical "corrupt state data detected"
  if [[ "$lastU" -lt 0 ]]; then
    echo "$rate_mb_s -1"
    return 0
  fi

  local time_left_h
  time_left_h=$(printf "%.0f" "$(bc -l <<< "($total_kb - $lastU) / $rate_kb_s / 3600")")

  if [[ "$time_left_h" -lt 0 ]]; then
    time_left_h=0
  fi

  echo "$rate_mb_s $time_left_h"
}

# --- Arg parsing ---
PARSED_ARGS=$(
  getopt -o w:W:c:C:x:X:rhH --long warning:,critical:,exclude:,data-dir:,reset,help -- "$@"
) || critical "invalid arguments (use --help)"
eval set -- "$PARSED_ARGS"

while true; do
  case "$1" in
    -w|-W|--warning)  THRESHOLD_WARN="$2"; shift 2 ;;
    -c|-C|--critical) THRESHOLD_CRIT="$2"; shift 2 ;;
    -x|-X|--exclude)  EXCLUDE_FS="$2"; shift 2 ;;
    --data-dir)       DATA_DIR="$2"; shift 2 ;;
    -r|--reset)       RESET_STATE=true; shift ;;
    -h|-H|--help)     show_help; exit $STATE_OK ;;
    --) shift; break ;;
    *) critical "argument parsing failure" ;;
  esac
done

# Reset state and exit OK (operational action)
if [[ "$RESET_STATE" == "true" ]]; then
  reset_state
fi

# Validate numeric thresholds and relationship
[[ "$THRESHOLD_WARN" =~ ^[0-9]+$ ]] || critical "--warning must be integer hours"
[[ "$THRESHOLD_CRIT" =~ ^[0-9]+$ ]] || critical "--critical must be integer hours"
[[ "$THRESHOLD_WARN" -ge "$THRESHOLD_CRIT" ]] || critical "warning must be >= critical"

main() {
  mkdir -p "$DATA_DIR" || critical "cannot create data dir: $DATA_DIR"

  local current_time
  current_time=$(date +%s)

  local final_status=$STATE_OK

  local crit_msg="" warn_msg="" ok_msg="" warm_msg=""
  local perfdata=""

  local df_args="-k -P"
  for fs in ${EXCLUDE_FS//|/ }; do
    df_args="$df_args -x $fs"
  done

  while IFS=$'\t' read -r mnt used_kb total_kb; do
    [[ -n "$mnt" ]] || continue
    [[ "$used_kb" =~ ^[0-9]+$ ]] || critical "bad used KB from df for $mnt"
    [[ "$total_kb" =~ ^[0-9]+$ ]] || critical "bad total KB from df for $mnt"

    local state_file="$DATA_DIR/disk_${mnt//\//_}.txt"
    [[ "$mnt" == "/" ]] && state_file="$DATA_DIR/disk_root.txt"

    local history=""
    if [[ -f "$state_file" ]]; then
      history=$(awk -F',' -v now="$current_time" '$1 > (now - 604800)' "$state_file" || true)
    fi

    history="${history:+$history$'\n'}$current_time,$used_kb"

    local tmp="${state_file}.$$"
    printf "%s\n" "$history" > "$tmp" || critical "cannot write temp state file: $tmp"
    mv -f "$tmp" "$state_file" || critical "cannot move state file into place: $state_file"

    local rate time_h
    read -r rate time_h < <(get_projection "$history" "$total_kb" "$current_time")

    perfdata+="'$mnt'=${rate}MB/s; "

    if [[ "$time_h" -eq -1 ]]; then
      warm_msg+="$mnt; "
      continue
    fi

    if [[ "$time_h" -le "$THRESHOLD_CRIT" ]]; then
      crit_msg+="$mnt ${time_h}h; "
      final_status=$STATE_CRITICAL
    elif [[ "$time_h" -le "$THRESHOLD_WARN" ]]; then
      warn_msg+="$mnt ${time_h}h; "
      [[ $final_status -eq $STATE_OK ]] && final_status=$STATE_WARNING
    else
      ok_msg+="$mnt ${time_h}h; "
    fi
  done < <(
    df $df_args | awk 'NR>1 {print $NF "\t" $3 "\t" $2}'
  )

  # Trim trailing "; "
  crit_msg="${crit_msg%; }"
  warn_msg="${warn_msg%; }"
  ok_msg="${ok_msg%; }"
  warm_msg="${warm_msg%; }"
  perfdata="${perfdata%; }"

  # Build summary by severity
  local summary=""
  [[ -n "$crit_msg" ]] && summary+="CRIT[$crit_msg] "
  [[ -n "$warn_msg" ]] && summary+="WARN[$warn_msg] "
  [[ -n "$ok_msg"   ]] && summary+="OK[$ok_msg] "
  [[ -n "$warm_msg" ]] && summary+="WARM[$warm_msg (need ~ $((2*WINDOW_HOURS))h history)] "
  summary="${summary% }"

  case $final_status in
    $STATE_OK)       echo -n "OK: $summary | $perfdata" ;;
    $STATE_WARNING)  echo -n "WARNING: $summary | $perfdata" ;;
    $STATE_CRITICAL) echo -n "CRITICAL: $summary | $perfdata" ;;
    *)               echo -n "UNKNOWN: unexpected status | $perfdata"; exit $STATE_UNKNOWN ;;
  esac

  exit $final_status
}

main
